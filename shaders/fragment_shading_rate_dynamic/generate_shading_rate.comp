#version 450
/* Copyright (c) 2020-2021, Holochip
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 the "License";
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0, r8ui) uniform readonly uimage2D input_frequency;
layout(binding = 1, r8ui) uniform writeonly uimage2D output_sampling_rate;

layout(binding = 2) buffer FrequencyInformation {
     uvec4 settings; // {frame_width, frame_height, output_width, output_height}
     uvec4 frequency_information; // { max_rate_x, max_rate_y, n_rates, ...}
     uvec2 rates[];
 } params;

void main()
{
    const uint x0 = gl_GlobalInvocationID.x, 
               y0 = gl_GlobalInvocationID.y,
               frame_width = params.settings[0], 
               frame_height = params.settings[1],
               output_width = params.settings[2],
               output_height = params.settings[3];


    const uint delta_x = max(1, frame_width / output_width),
               delta_y = max(1, frame_height / output_height);
    if (x0 >= output_width || y0 >= output_height){
        return;
    }

    float frequency = 0;
    for (uint i = 0; i < delta_x; ++i)
    {
        for (uint j = 0; j < delta_y; ++j)
        {
            float frequency_input = float(imageLoad(input_frequency, ivec2(delta_x*x0 + i, delta_y*y0 + j))) / 127.f;
            frequency = max(frequency, frequency_input);
        }
    }
    frequency = max(0, min(sqrt(frequency), 1));

    const float min_rate = 1,
                max_rate = max(params.frequency_information.x, params.frequency_information.y);
    const float optimal_rate = round(frequency * min_rate + (1 - frequency) * max_rate);

    const uint n_rates = params.frequency_information.z;
    uint optimal_rate_index = 0;
    float current_cost = 1000;
    for (uint i = 0; i < n_rates; ++i)
    {
        uvec2 rate = params.rates[i];
        float cost = (rate.x - optimal_rate) * (rate.x - optimal_rate) + (rate.y - optimal_rate) * (rate.y - optimal_rate);
        if (cost < current_cost){
            current_cost = cost;
            optimal_rate_index = i;
        }
    }
    //optimal_rate_index = uint(round(min(n_rates - 1, max(0, frequency * n_rates))));

    uint optimal_rate_x = params.rates[optimal_rate_index].x, optimal_rate_y = params.rates[optimal_rate_index].y;
    uint rate_code = uint(optimal_rate_x >> 1) | (optimal_rate_y << 1);
    imageStore(output_sampling_rate, ivec2(x0, y0), uvec4(rate_code));
}