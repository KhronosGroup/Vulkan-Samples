/* Copyright (c) 2019-2020, Sascha Willems
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 the "License";
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#version 460
#extension GL_EXT_ray_tracing : enable

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
} cam;

struct Payload
{
  vec4 color;
  vec4 intersection; // {x, y, z, intersectionType}
  vec4 normal; // {nx, ny, nz, distance}
};

vec3 heatmap(float value, float minValue, float maxValue)
{
  float scaled = (min(max(value, minValue), maxValue) - minValue) / (maxValue - minValue);
  float r = scaled * (3.14159265359 / 2.);
  return vec3(sin(r), sin(2 * r), cos(r));
}

layout(location = 0) rayPayloadEXT Payload hitValue;
layout (constant_id = 0) const uint render_mode = 0;
layout (constant_id = 1) const uint maxRays = 12;

void main() 
{
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec4 origin = cam.viewInverse * vec4(0,0,0,1);
	vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1) ;
	vec4 direction = cam.viewInverse*vec4(normalize(target.xyz), 0) ;

	float tmin = 0.001;
	float tmax = 10000.0;

	uint max_rays = maxRays;
	if (render_mode != 0)
	{
		max_rays = 1;
	}

	uint object_type = 100;
	vec4 color = vec4(0, 0, 0, 1);
	// 0 = normal, 1 = shadow, 2 = AO
	uint current_mode = 0;
	float expectedDistance = -1;
	for (uint i = 0; i < max_rays && current_mode < 100; ++i)
	{
		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
		object_type = uint(hitValue.intersection.w);
		const vec3 object_intersection_pt = hitValue.intersection.xyz;
		const vec3 object_normal = hitValue.normal.xyz;
		if (object_type == 0)
		{
			color = hitValue.color;
			
			//shadow
			{
				const float shadow_mult = 2;
				const float shadow_scale = 0.25;
				vec3 lightPt = vec3(0, -20, 0);
				vec3 currentDirection = lightPt - hitValue.intersection.xyz;
				expectedDistance = sqrt(dot(currentDirection, currentDirection));
				currentDirection = normalize(currentDirection);
				traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, object_intersection_pt, tmin, currentDirection, tmax, 0);
				float r = expectedDistance;
				float actDistance = hitValue.normal.w;
				float scale = actDistance < expectedDistance ? shadow_scale : 1;
				scale = min(scale * shadow_mult, 1);
				color.xyz *= scale;
				current_mode = 101;
				if (render_mode == 5)
				{
					color = vec4(scale, scale, scale, 1);
					break;
				}
			}
			
			// ambient occlusion
			{
				const float ao_mult = 1;
				uint max_ao_each = 2;
				uint max_ao = max_ao_each * max_ao_each;
				const float max_dist = 2;
				float accumulated_ao = 0.f;
				vec3 u = dot(object_normal, vec3(0, 0, 1)) > 0.9 ? cross(object_normal, vec3(1, 0, 0)) : cross(object_normal, vec3(0, 0, 1));
				vec3 v = cross(object_normal, u);
				float accumulated_factor = 0;
				for (uint j = 0; j < max_ao_each; ++j)
				{
					float phi = 0.5*(-3.14159 + 2 * 3.14159 * (float(j + 1) / float(max_ao_each + 2)));
					for (uint k = 0; k < max_ao_each; ++k){
						float theta =  0.5*(-3.14159 + 2 * 3.14159 * (float(k + 1) / float(max_ao_each + 2)));
						float x = cos(phi) * sin(theta);
						float y = sin(phi) * sin(theta);
						float z = cos(theta);
						vec3 direction = x * u + y * v + z * object_normal;
						traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, object_intersection_pt, tmin, direction, tmax, 0);
						float ao = min(hitValue.normal.w, max_dist);
						float factor = 0.2 + 0.8 * z * z;
						accumulated_factor += factor;
						accumulated_ao += ao * factor;
					}
				}
				accumulated_ao /= (max_dist * accumulated_factor);
				accumulated_ao *= accumulated_ao;
				accumulated_ao = max(min((accumulated_ao) * ao_mult, 1), 0);
				if (render_mode == 6)
				{
					color = vec4(accumulated_ao, accumulated_ao, accumulated_ao, 1);
					break;
				}
				
				color.xyz *= accumulated_ao;
			}
			
		} else if (object_type == 1)
		{
			color = vec4(0.25, 0.25, 0.25, 1);
			break;
		}
	}

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), color);
}
