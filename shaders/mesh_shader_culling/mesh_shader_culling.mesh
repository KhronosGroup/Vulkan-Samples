#version 450
/* Copyright (c) 2023, Holochip Corporation
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 the "License";
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#extension GL_EXT_mesh_shader: require

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64 * 4, max_primitives = 124 * 2) out;

// Example of how to read shared data from its associated task shader:
// 1) the same structure must be defined (name can vary however):

struct SharedData
{
    vec4  positionTransformation;
    int   N;
    int   meshletsNumber;
    float subDimension;
    float cullRadius;
};

// 2) using the following command to "establish the connection" (variable name can vary):

taskPayloadSharedEXT SharedData sharedData;

// Example of a default output layout and location format:

layout (location=0) out vec4 perVertex[];
layout (location=1) perprimitiveEXT out vec4 perPrimitiveEXT[];
layout (location=3) out vec3 outColor[];

// Define some constants in order to create an identical meshlet square, using two triangles:
// 1) a simplified vertex data, using vec2 format

const vec2 unitVertex_0 = vec2(-0.5f,  0.5f);
const vec2 unitVertex_1 = vec2( 0.5f,  0.5f);
const vec2 unitVertex_2 = vec2( 0.5f, -0.5f);
const vec2 unitVertex_3 = vec2(-0.5f, -0.5f);

// 2) index data associated with the vertex data, triangle defined using right-hand rule

const uvec3 unitPrimitive_0 = uvec3(0, 1, 2);
const uvec3 unitPrimitive_1 = uvec3(2, 0, 3);

void main()
{
    // 1) The first variable means: the total number of vertices to be created:
    // 2) The second variable means total number of primitives to be created (at least 3 index per primitive):

    SetMeshOutputsEXT( sharedData.meshletsNumber * 4, sharedData.meshletsNumber * 2);

    // Creating meshlets:
    for (uint k = 0; k < sharedData.meshletsNumber; k++)
    {
        // processing index, "breaking" a linear index into a coordinate index
        // (i.e., (i, j) means the ith column and jth row)

        float j = floor(k / sharedData.N);   // calculating which row this meshlet belongs to
        float i = k - j * sharedData.N;      // calculating which column this meshlet belongs to

        // translate the identical meshlet to its targeted position:

        vec2 deltaPosition_xy = ( 2.0f * vec2( i, j ) - sharedData.N - 1.0f ) * sharedData.subDimension;

        // this is the displacement with respect to the origin, displacement is used in cull logic:

        vec4 displacement = vec4(deltaPosition_xy, 0.0f, 1.0f);

        // the actual position of each meshlet:

        vec4 position = displacement + sharedData.positionTransformation;
        float squareRadius = position.x * position.x + position.y * position.y;

        // Cull Logic: only is the meshlet center position is within the view circle defined by the cull radius,
        // then this very meshlet will be generated. Otherwise, meshlet will NOT be generated.

        if (squareRadius < sharedData.cullRadius * sharedData.cullRadius)
        {
            // Vertices:

            gl_MeshVerticesEXT[ k * 4 + 0 ].gl_Position = vec4(2.0 * sharedData.subDimension * unitVertex_0, 0.0f, 1.0f) + sharedData.positionTransformation + displacement;
            gl_MeshVerticesEXT[ k * 4 + 1 ].gl_Position = vec4(2.0 * sharedData.subDimension * unitVertex_1, 0.0f, 1.0f) + sharedData.positionTransformation + displacement;
            gl_MeshVerticesEXT[ k * 4 + 2 ].gl_Position = vec4(2.0 * sharedData.subDimension * unitVertex_2, 0.0f, 1.0f) + sharedData.positionTransformation + displacement;
            gl_MeshVerticesEXT[ k * 4 + 3 ].gl_Position = vec4(2.0 * sharedData.subDimension * unitVertex_3, 0.0f, 1.0f) + sharedData.positionTransformation + displacement;

            // Indices

            gl_PrimitiveTriangleIndicesEXT[ k * 2 + 0 ] = unitPrimitive_0 + k * uvec3(4);
            gl_PrimitiveTriangleIndicesEXT[ k * 2 + 1 ] = unitPrimitive_1 + k * uvec3(4);

            // Assigning the color output:

            vec3 color = vec3( 1.0f, 0.0f, 0.0f ) * ( k + 1 ) / sharedData.meshletsNumber;

            outColor[ k * 4 + 0] = color;
            outColor[ k * 4 + 1] = color;
            outColor[ k * 4 + 2] = color;
            outColor[ k * 4 + 3] = color;
        }
    }
}
