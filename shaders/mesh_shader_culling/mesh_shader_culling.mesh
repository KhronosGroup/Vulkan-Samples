#version 450
/* Copyright (c) 2023, Holochip Corporation
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 the "License";
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#extension GL_EXT_mesh_shader: require

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64 * 4, max_primitives = 124 * 2) out;

// Structures

struct PrimitiveColor
{
    vec3 color_1;
    vec3 color_2;
};

// Shared Data from Task:

taskPayloadSharedEXT vec4 deltaPosition;

// Output

layout (location=0) out vec4 perVertex[];
layout (location=1) perprimitiveEXT out vec4 perPrimitiveEXT[];
layout (location=3) out vec3 outColor[];


// Defined constants

// 1) Unit vertices and primitives

const vec2 unitVertex_0 = vec2(-0.5f,  0.5f);
const vec2 unitVertex_1 = vec2( 0.5f,  0.5f);
const vec2 unitVertex_2 = vec2( 0.5f, -0.5f);
const vec2 unitVertex_3 = vec2(-0.5f, -0.5f);

const uvec3 unitPrimitive_0 = uvec3(0, 1, 2);
const uvec3 unitPrimitive_1 = uvec3(2, 0, 3);


//Test
const float squareDimension = 1.0f;

int N = 8;
int meshletsNumber = N * N;

float subDimension = squareDimension / N * 0.5f;

void main()
{
    SetMeshOutputsEXT( meshletsNumber * 4, meshletsNumber * 2);

    vec4 displacement;

    for (uint i = 0; i < meshletsNumber; i++)
    {

        float j = floor(i / N);
        float k = i - j * N;

        vec2 deltaPosition_xy = ( 2.0f * vec2(k, j) - N - 1.0f ) * subDimension;
        displacement = vec4(deltaPosition_xy, 0.0f, 1.0f);

        vec4 position = displacement + deltaPosition;

        float radius = position.x * position.x + position.y * position.y;

        if (radius < 1.0)
        {
            gl_MeshVerticesEXT[ i * 4 + 0 ].gl_Position = vec4(unitVertex_0 / N, 0.0f, 1.0f) + deltaPosition + displacement;
        gl_MeshVerticesEXT[ i * 4 + 1 ].gl_Position = vec4(unitVertex_1 / N, 0.0f, 1.0f) + deltaPosition + displacement;
        gl_MeshVerticesEXT[ i * 4 + 2 ].gl_Position = vec4(unitVertex_2 / N, 0.0f, 1.0f) + deltaPosition + displacement;
        gl_MeshVerticesEXT[ i * 4 + 3 ].gl_Position = vec4(unitVertex_3 / N, 0.0f, 1.0f) + deltaPosition + displacement;

        gl_PrimitiveTriangleIndicesEXT[ i * 2 + 0 ] = unitPrimitive_0 + uvec3(4) * i;
        gl_PrimitiveTriangleIndicesEXT[ i * 2 + 1 ] = unitPrimitive_1 + uvec3(4) * i;

        vec3 color;

        color = vec3(1.0, 0.0, 0.0) * (i + 1) / meshletsNumber;

        outColor[ i * 4 + 0] = color;
        outColor[ i * 4 + 1] = color;
        outColor[ i * 4 + 2] = color;
            outColor[ i * 4 + 3] = color;
        }
    }
}