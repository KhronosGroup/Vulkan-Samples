#version 460

/* Copyright (c) 2024-2026, Arm Limited and Contributors
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 the "License";
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Compute shader which reads from three tensors representing RGB images (input_tensor, output_tensor and postprocessed_tensor)
// and draws them to an output image.

// Enable the extension that allows us to read from Tensors.
#extension GL_ARM_tensors : enable

// Our three input tensors, each being a 4-dimensional array of floats
layout (set = 0, binding = 0) uniform tensorARM<float, 4> input_tensor;
layout (set = 0, binding = 1) uniform tensorARM<float, 4> output_tensor;
layout (set = 0, binding = 2) uniform tensorARM<float, 4> postprocessed_tensor;

// Output image to write to
layout(rgba8, set = 0, binding = 3) writeonly uniform image2D output_image;

// Push constants to provide the size of the output image, so that we can position things correctly
layout(push_constant) uniform push_constants
{
	ivec2 output_image_size;
};

// If the given pixel_coord is within the rectangle described by (left,top,width, height), then updates
// `color` with data from the tensor at an interpolated location based on the position in the rectangle.
#define DEFINE_DRAW_TENSOR(FUNC_NAME, TENSOR_NAME)                                        \
void FUNC_NAME(inout vec4 color, ivec2 pixel_coord,                                       \
               int left, int top, int width, int height)                                  \
{                                                                                         \
    if (pixel_coord.x >= left && pixel_coord.x < left + width &&                          \
        pixel_coord.y >= top  && pixel_coord.y < top + height)                            \
    {                                                                                     \
        uint tensor_width  = tensorSizeARM(TENSOR_NAME, 2);                               \
        uint tensor_height = tensorSizeARM(TENSOR_NAME, 1);                               \
                                                                                          \
        uint[4] tensor_coords = {                                                         \
            0,                                                                            \
            uint(float(pixel_coord.y - top)  / float(height) * float(tensor_height)),     \
            uint(float(pixel_coord.x - left) / float(width)  * float(tensor_width)),      \
            0                                                                             \
        };                                                                                \
                                                                                          \
        float[3] value;                                                                   \
        tensorReadARM(TENSOR_NAME, tensor_coords, value);                                 \
        color = vec4(value[0], value[1], value[2], 1.0);                                  \
    }                                                                                     \
}

// Generate the three concrete functions
DEFINE_DRAW_TENSOR(draw_input_tensor,         input_tensor)
DEFINE_DRAW_TENSOR(draw_output_tensor,        output_tensor)
DEFINE_DRAW_TENSOR(draw_postprocessed_tensor, postprocessed_tensor)

layout(local_size_x = 8, local_size_y = 8) in;
void main() 
{
	ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
	if (pixel_coord.x >= output_image_size.x || pixel_coord.y >= output_image_size.y)
	{
		return; // Out-of-bounds
	}

	vec4 out_color = vec4(0.0f, 0.0f, 0.0f, 1.0f);

	// Position the input_tensor to the left of the middle, the output tensor in the middle and postprocessed_tensor to the right of the middle
	draw_input_tensor(out_color, pixel_coord, output_image_size.x / 2 - 500, output_image_size.y / 2 - 100, 200, 200);
	draw_output_tensor(out_color, pixel_coord, output_image_size.x / 2 - 100, output_image_size.y / 2 - 100, 200, 200);
	draw_postprocessed_tensor(out_color, pixel_coord, output_image_size.x / 2 + 300, output_image_size.y / 2 - 100, 200, 200);

    imageStore(output_image, ivec2(pixel_coord), out_color);
}
