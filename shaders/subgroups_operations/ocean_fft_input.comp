#version 450
#extension GL_KHR_shader_subgroup_basic : enable

/* Copyright (c) 2023, Mobica Limited
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 the "License";
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

#define PI 3.141592f
#define PI2 6.283184
#define GRAVITY 9.81f

struct Complex
{
	float real;
	float imag;
};

struct FFTInputData
{
	Complex tilde;
	Complex tilde_conj;
};

layout (set = 0, binding = 0) uniform FFTParametersUbo
{
	float amplitude;
	float len;
	vec2  wind;
	uint  grid_size;
} fftUbo;

layout (std140, set = 0, binding = 1) buffer FFTInputDataBuffer
{
	FFTInputData data[];
};

Complex complexMultiplication(Complex a, float scalar)
{
	Complex res;
	res.real = scalar * a.real;
	res.imag = scalar * a.imag;
	return res;
}

Complex conjugate(Complex a)
{
	Complex res;
	res.real = a.real;
	res.imag = -a.imag;
	return res;
}

float phillips_spectrum(uint n, uint m)
{
	vec2 k = vec2(PI * (2.0f * n - fftUbo.grid_size) / fftUbo.len,  PI * (2.0f * m - fftUbo.grid_size) / fftUbo.len);

	float k_length = length(k);
	if (k_length < 0.000001f)
		return 0.0f;
	
	float k_len2 = k_length * k_length;
	float k_len4 = k_len2 * k_len2;

	float k_dot_wind = dot(normalize(k), normalize(fftUbo.wind));
	float k_dot_wind2 = k_dot_wind * k_dot_wind;

	float wind_len = length(fftUbo.wind);
	float L = wind_len * wind_len / GRAVITY;
	float L2 = L * L;

	float damping = 0.001f;
	float c2 = L2 * damping * damping;

	return fftUbo.amplitude * exp(-1.0f / (k_len2 * L2)) / k_len4 * k_dot_wind2 * exp(-k_len2 * c2);
}

// source: https://stackoverflow.com/a/74419913
float random(vec2 st)
{
    float rndVal = fract(sin(dot(st, vec2(12.9898f, 78.233f))) * 43758.5453123f);
    if (rndVal < 0.000001f) return 0.000001f;
    return rndVal;
}

Complex gaussionRndVal(vec2 seed)
{
	float x1, x2, w, w2;
	x1 = random(seed);
	x1 = -2.0f * log(x1);
	x2 = random(seed) * PI2;

	w = sqrt(x1) * cos(x2);

	Complex res;
	res.real = x1 * w;
	res.imag = x2 * w;
	return res;
}

Complex hTilde(uint n, uint m)
{
	Complex rnd = gaussionRndVal(vec2(abs(n), abs(m)));
	return complexMultiplication(rnd, sqrt(phillips_spectrum(n, m) / 2.0f));
}

void main()
{
	uint idx = gl_GlobalInvocationID.x * gl_SubgroupInvocationID + gl_GlobalInvocationID.y * gl_SubgroupInvocationID +  gl_GlobalInvocationID.z * gl_SubgroupInvocationID;
	subgroupMemoryBarrierBuffer();
	uint n = gl_GlobalInvocationID.x;
	uint m = gl_GlobalInvocationID.y;


	data[idx].tilde = hTilde(n, m); // possible issue
	data[idx].tilde_conj = conjugate(data[idx].tilde);
}
