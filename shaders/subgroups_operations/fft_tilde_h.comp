#version 450
#extension GL_KHR_shader_subgroup_basic : enable

#define PI 3.141592f
#define GRAVITY 9.81f

/* Copyright (c) 2023, Mobica Limited
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 the "License";
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout (std140, binding = 0) readonly buffer TildeH0K
{
        vec2 data[];
}
tilde_h0_k;

layout (std140, binding = 1) readonly buffer TildeH0MinusK
{
        vec2 data[];
}
tilde_h0_minus_k;

layout (binding = 2, rgba32f) writeonly uniform image2D tilde_h_kt_dx;
layout (binding = 3, rgba32f) writeonly uniform image2D tilde_h_kt_dy;
layout (binding = 4, rgba32f) writeonly uniform image2D tilde_h_kt_dz;

layout (binding = 5) uniform FFTParametersUbo
{
	float amplitude;
	float len;
	uint  grid_size;
	vec2  wind;
} fftUbo;

layout (binding = 6) uniform Time
{
	float time;
} t;

struct Complex
{
	float real;
	float imag;
};

Complex complex_add(Complex c1, Complex c2)
{
	Complex res;
	res.real = c1.real + c2.real;
	res.imag = c1.imag + c2.imag;
	return res;
}

Complex complex_multiply(Complex c1, Complex c2)
{
	Complex res;
	res.real = c1.real * c2.real - c1.imag * c2.imag;
	res.imag = c1.real * c2.imag + c1.imag * c2.real;
	return res;
}

Complex complex_conj(Complex c)
{
	Complex res;
	res.real = c.real;
	res.imag = -c.imag;
	return res;
}

void main()
{
        float L = fftUbo.len;

	vec2 uv = gl_GlobalInvocationID.xy;

	vec2 k = vec2( (2.0f * PI * uv.x) / L, (2.0f * PI * uv.y) / L);

	float k_mag = length(k);
	if (k_mag < 0.00001f) k_mag = 0.00001f;

	float w = sqrt(GRAVITY * k_mag);

	ivec2 pixel_pos = ivec2(gl_GlobalInvocationID.xy);

        uint idx =  pixel_pos.x + pixel_pos.y;
        vec2 h0_k = tilde_h0_k.data[idx];

	Complex amp = Complex(h0_k.x, h0_k.y);
        Complex exp_iwt = Complex(cos(w * t.time), sin(w * t.time));

        vec2 h0_minus_k = tilde_h0_minus_k.data[idx];

	Complex amp_conj = Complex(h0_minus_k.x, h0_minus_k.y);
        Complex exp_minus_iwt = Complex(cos(w * t.time), -sin(w * t.time));


	Complex h_k_t_dy = complex_add( complex_multiply(amp, exp_iwt), complex_multiply(amp_conj, exp_minus_iwt));
        imageStore(tilde_h_kt_dy, pixel_pos, vec4(h_k_t_dy.real, h_k_t_dy.imag, 0.0f, 1.0f));

	Complex dx = Complex(0.0f, -k.x / k_mag);
	Complex h_k_t_dx = complex_multiply(dx, h_k_t_dy);
        imageStore(tilde_h_kt_dx, pixel_pos, vec4(h_k_t_dx.real, h_k_t_dx.imag, 0.0f, 1.0f));

	Complex dz = Complex(0.0f, -k.y / k_mag);
	Complex h_k_t_dz = complex_multiply(dz, h_k_t_dy);
        imageStore(tilde_h_kt_dz, pixel_pos, vec4(h_k_t_dz.real, h_k_t_dz.imag, 0.0f, 1.0f));
}
