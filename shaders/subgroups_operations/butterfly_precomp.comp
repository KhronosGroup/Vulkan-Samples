#version 460 core

#define PI_32F 3.14159265358979f
#define DISPLACEMENT_MAP_DIM 256

layout (local_size_x = 8, local_size_y = 32) in;

layout (binding = 0, rgba32f) writeonly uniform image2D u_butterfly_precomp;

layout (std430, binding = 1) buffer indices
{
        int data[];
}
bit_reversed_indices;


void main()
{
        vec2 pos = gl_GlobalInvocationID.xy;

        int N = DISPLACEMENT_MAP_DIM;

        // Twiddle factor exponent, Thesis, Section 4.2.6, Eq 4.6
        float k = mod(pos.y * (float(N) / pow(2, pos.x + 1)), N);

        // Thesis, Section 4.2.6, Eq 4.7
        int butterfly_span = int(pow(2, pos.x));
        int butterfly_wing = 0;

        if ((mod(pos.y, pow(2, pos.x + 1))) < butterfly_span) butterfly_wing = 1;

        ivec2 pixel_pos = ivec2(gl_GlobalInvocationID.xy);

        vec4 result;
        result.x = cos(2.f * PI_32F * k / float(N));	// Twiddle factor real part
        result.y = sin(2.f * PI_32F * k / float(N));	// Twiddle factor imaginary part

        // Store the sample indices for the next stage
        if (pos.x == 0)
        {
                if (butterfly_wing == 1)
                {
                        result.z = bit_reversed_indices.data[int(pos.y)];
                        result.w = bit_reversed_indices.data[int(pos.y + 1)];
                }
                else
                {
                        result.z = bit_reversed_indices.data[int(pos.y - 1)];
                        result.w =  bit_reversed_indices.data[int(pos.y)];
                }
        }
        else
        {
                if (butterfly_wing == 1)
                {
                        result.z = pos.y;
                        result.w = pos.y + butterfly_span;
                }
                else
                {
                        result.z = pos.y - butterfly_span;
                        result.w = pos.y;
                }
        }

        imageStore(u_butterfly_precomp, pixel_pos, result);
}

