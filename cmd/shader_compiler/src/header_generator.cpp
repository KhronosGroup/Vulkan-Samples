#include "header_generator.hpp"

#include <fstream>
#include <iostream>
#include <string>

namespace shader_compiler
{
namespace detail
{
std::string snake_to_pascal(const std::string &snake)
{
	std::string pascal;

	for (size_t i = 0; i < snake.size(); i++)
	{
		if (i == 0)
		{
			pascal += toupper(snake[0]);
			continue;
		}

		if (snake[i] == '_')
		{
			pascal += toupper(snake[i + 1]);
			i++;
			continue;
		}

		pascal += snake[i];
	}

	return pascal;
}
}        // namespace detail

void generate_shader_header(const ShaderDescriptor &descriptor, const std::string &output_file)
{
	std::ofstream output_stream(output_file);

	if (!output_stream.is_open())
	{
		throw std::runtime_error("Could not open output file for writing");
	}

	output_stream << "#pragma once" << std::endl;
	output_stream << std::endl;
	output_stream << "/* DO NOT EDIT */" << std::endl;
	output_stream << "/* This file was generated by the shader compiler */" << std::endl;
	output_stream << std::endl;

	output_stream << "#include <cstdint>" << std::endl;
	output_stream << "#include <vector>" << std::endl;
	output_stream << "#include <components/shaders/shader_resources.hpp>" << std::endl;
	output_stream << std::endl;

	output_stream << "namespace shaders" << std::endl;
	output_stream << "{" << std::endl;
	output_stream << std::endl;

	output_stream << "// clang-format off" << std::endl;

	for (const auto &variant_pair : descriptor.variants)
	{
		auto &hash    = variant_pair.first;
		auto &variant = variant_pair.second;

		output_stream << "\tconstexpr uint32_t " << detail::snake_to_pascal(descriptor.name) << "__" << hash << "[] = [" << std::endl;

		for (size_t i = 0; i < variant.spirv.size(); i++)
		{
			if (i % 50 == 0)
			{
				if (i != 0)
				{
					output_stream << std::endl;
				}

				output_stream << "\t\t";
				output_stream << variant.spirv[i];

				if (i != variant.spirv.size() - 1)
				{
					output_stream << ",";
				}
			}
			else
			{
				output_stream << variant.spirv[i];

				if (i != variant.spirv.size() - 1)
				{
					output_stream << ",";
				}
			}
		}

		output_stream << "];" << std::endl;
		output_stream << std::endl;

		output_stream << "\tconstexpr size_t " << detail::snake_to_pascal(descriptor.name) << "__" << hash << "_size = " << variant.spirv.size() << ";" << std::endl;
		output_stream << std::endl;
	}

	output_stream << "// clang-format on" << std::endl;
	output_stream << std::endl;

	output_stream << "class " << detail::snake_to_pascal(descriptor.name) << std::endl;
	output_stream << "{" << std::endl;
	output_stream << "\tpublic:" << std::endl;

	output_stream << "\t\tstd::vector<uint32_t> get_variant(const shaders::CompilerConfig &variant) const" << std::endl;
	output_stream << "\t\t{" << std::endl;

	output_stream << "\t\t\tswitch (variant.hash())" << std::endl;
	output_stream << "\t\t\t{" << std::endl;

	for (const auto &variant_pair : descriptor.variants)
	{
		auto &hash    = variant_pair.first;
		auto &variant = variant_pair.second;

		output_stream << "\t\t\t\tcase " << hash << ":" << std::endl;
		output_stream << "\t\t\t\t\treturn std::vector<uint32_t>(" << detail::snake_to_pascal(descriptor.name) << "__" << hash << ", " << detail::snake_to_pascal(descriptor.name) << "__" << hash << " + " << detail::snake_to_pascal(descriptor.name) << "__" << hash << "_size);" << std::endl;
		output_stream << "\t\t\t\t\tbreak;" << std::endl;
	}

	output_stream << "\t\t\t\tdefault:" << std::endl;
	output_stream << "\t\t\t\t\tthrow std::runtime_error(\"Invalid shader variant\");" << std::endl;
	output_stream << "\t\t\t}" << std::endl;

	output_stream << "};" << std::endl;

	output_stream << std::endl;
	output_stream << "}        // namespace shaders" << std::endl;

	output_stream.close();
}
}        // namespace shader_compiler